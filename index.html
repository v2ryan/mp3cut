<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP3/MP4 剪輯神器</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- LameJS for MP3 Encoding (Lightweight) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>
    <!-- FFmpeg.wasm for Video Processing (Heavyweight) -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.10.1/dist/ffmpeg.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        .hidden { display: none; }
    </style>
</head>
<body class="bg-slate-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white rounded-2xl shadow-xl w-full max-w-md overflow-hidden">
        <!-- Header -->
        <div class="bg-indigo-600 p-6 text-center">
            <h1 class="text-2xl font-bold text-white mb-2">MP3/MP4 剪輯神器 ✂️</h1>
            <p class="text-indigo-100 text-sm">純前端處理，支援影片與音訊</p>
        </div>

        <!-- Content -->
        <div class="p-6 space-y-6">
            
            <!-- Step 1: Upload -->
            <div class="space-y-2">
                <label class="block text-sm font-medium text-slate-700">1. 上傳檔案 (MP3 或 MP4)</label>
                <div class="relative group">
                    <input type="file" id="fileInput" accept=".mp3,.mp4,audio/*,video/*" class="hidden" onchange="handleFileSelect(this)">
                    <label for="fileInput" class="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed border-slate-300 rounded-lg cursor-pointer bg-slate-50 hover:bg-slate-100 transition-colors group-hover:border-indigo-400">
                        <div class="flex flex-col items-center justify-center pt-5 pb-6">
                            <svg class="w-8 h-8 mb-3 text-slate-400 group-hover:text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                            <p class="mb-2 text-sm text-slate-500"><span class="font-semibold text-indigo-600">點擊上傳</span> 或拖拉檔案</p>
                            <p id="fileName" class="text-xs text-slate-400 mt-1 max-w-[80%] truncate">未選擇檔案</p>
                        </div>
                    </label>
                </div>
            </div>

            <!-- Step 2: Settings -->
            <div class="space-y-4 opacity-50 pointer-events-none transition-opacity duration-200" id="settingsArea">
                
                <!-- Time Setting -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-slate-700">2. 設定要 Cut 走前面幾多秒</label>
                    <div class="relative w-full">
                        <input type="number" id="cutSeconds" value="5" min="0" step="0.1" class="block w-full p-3 pl-4 text-sm text-slate-900 border border-slate-300 rounded-lg bg-slate-50 focus:ring-indigo-500 focus:border-indigo-500" placeholder="例如：5">
                        <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                            <span class="text-slate-500 text-sm">秒</span>
                        </div>
                    </div>
                </div>

                <!-- Output Format Setting -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-slate-700">3. 選擇輸出格式</label>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <input type="radio" id="formatMp3" name="outputFormat" value="mp3" checked class="hidden peer" onchange="handleFormatChange()">
                            <label for="formatMp3" class="inline-flex items-center justify-between w-full p-3 text-slate-500 bg-white border border-slate-200 rounded-lg cursor-pointer peer-checked:border-indigo-600 peer-checked:text-indigo-600 hover:text-slate-600 hover:bg-slate-50">                           
                                <div class="block">
                                    <div class="w-full text-sm font-semibold">MP3 (純音訊)</div>
                                    <div class="w-full text-xs">極速，適合只要聲音</div>
                                </div>
                                <svg class="w-5 h-5 ml-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"></path></svg>
                            </label>
                        </div>
                        <div>
                            <input type="radio" id="formatMp4" name="outputFormat" value="mp4" class="hidden peer" onchange="handleFormatChange()">
                            <label for="formatMp4" class="inline-flex items-center justify-between w-full p-3 text-slate-500 bg-white border border-slate-200 rounded-lg cursor-pointer peer-checked:border-indigo-600 peer-checked:text-indigo-600 hover:text-slate-600 hover:bg-slate-50">
                                <div class="block">
                                    <div class="w-full text-sm font-semibold">MP4 (影片)</div>
                                    <div class="w-full text-xs">需載入引擎 (~25MB)</div>
                                </div>
                                <svg class="w-5 h-5 ml-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 3: Action -->
            <button id="processBtn" onclick="startProcessing()" disabled class="w-full py-3.5 px-5 text-white bg-indigo-600 hover:bg-indigo-700 focus:ring-4 focus:outline-none focus:ring-indigo-300 font-medium rounded-lg text-sm text-center disabled:bg-slate-300 disabled:cursor-not-allowed transition-all shadow-md transform active:scale-95 flex justify-center items-center">
                開始處理
            </button>

            <!-- Status / Result -->
            <div id="statusArea" class="hidden p-4 mb-4 text-sm rounded-lg bg-slate-100" role="alert">
                <div class="flex items-center gap-2">
                    <svg id="loadingIcon" class="animate-spin h-5 w-5 text-indigo-600 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span id="statusText" class="font-medium text-slate-700">準備就緒</span>
                </div>
                <!-- Progress Bar for FFmpeg -->
                <div id="progressContainer" class="w-full bg-slate-300 rounded-full h-2.5 mt-3 hidden">
                    <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>

            <!-- Download Link -->
            <a id="downloadLink" href="#" class="hidden w-full py-3 px-5 text-indigo-700 bg-indigo-100 border border-indigo-200 hover:bg-indigo-200 focus:ring-4 focus:outline-none focus:ring-indigo-300 font-medium rounded-lg text-sm text-center transition-all flex items-center justify-center gap-2">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                下載檔案
            </a>

        </div>
    </div>

    <script>
        // --- Shared State ---
        let selectedFile = null;
        
        // --- Audio Context Engine (For MP3 Output) ---
        let audioContext = null;

        // --- FFmpeg Engine (For MP4 Output) ---
        let ffmpeg = null;
        const { createFFmpeg, fetchFile } = FFmpeg;

        function handleFileSelect(input) {
            if (input.files && input.files[0]) {
                selectedFile = input.files[0];
                document.getElementById('fileName').textContent = selectedFile.name;
                document.getElementById('fileName').classList.add('text-indigo-600');
                
                document.getElementById('settingsArea').classList.remove('opacity-50', 'pointer-events-none');
                document.getElementById('processBtn').disabled = false;
                
                resetUI();

                // Smart Default: If it's a video file, maybe user wants MP4 output? 
                // But we default to MP3 for speed unless user changes it.
                // Let's just validate:
                const isVideo = selectedFile.type.startsWith('video');
                if (!isVideo && document.querySelector('input[name="outputFormat"]:checked').value === 'mp4') {
                    // If user uploaded MP3 but had MP4 selected, switch back to MP3
                    document.getElementById('formatMp3').checked = true;
                    handleFormatChange();
                }
            }
        }

        function handleFormatChange() {
            resetUI();
            const format = document.querySelector('input[name="outputFormat"]:checked').value;
            // You could add logic here to warn user if they try to convert MP3 -> MP4 (which is weird but possible)
        }

        function resetUI() {
            document.getElementById('downloadLink').classList.add('hidden');
            document.getElementById('statusArea').classList.add('hidden');
            document.getElementById('progressContainer').classList.add('hidden');
            document.getElementById('statusArea').classList.remove('bg-red-100', 'text-red-700');
        }

        function startProcessing() {
            const format = document.querySelector('input[name="outputFormat"]:checked').value;
            
            // Validation
            if (!selectedFile) return alert('請先選擇檔案！');
            if (format === 'mp4' && !selectedFile.type.startsWith('video') && !selectedFile.name.endsWith('.mp4')) {
                // Converting MP3 to MP4 (video) is complex (needs black screen generation), keeping it simple:
                return alert('⚠️ 暫不支援將 MP3 轉為 MP4 影片。如果係 MP3 檔案，請選擇「MP3 (純音訊)」輸出。');
            }

            if (format === 'mp3') {
                processAudioOnly(); // Lightweight path
            } else {
                processVideoWithFFmpeg(); // Heavyweight path
            }
        }

        // ==========================================
        // Path 1: Lightweight Audio Processing (MP3/MP4 -> MP3)
        // ==========================================
        async function processAudioOnly() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const cutSeconds = parseFloat(document.getElementById('cutSeconds').value);
            
            updateStatus("讀取檔案中...", true);
            
            try {
                const arrayBuffer = await selectedFile.arrayBuffer();
                updateStatus("解碼音訊中 (Web Audio API)...", true);
                
                // AudioContext can decode audio from MP4 video files too!
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                if (cutSeconds >= audioBuffer.duration) throw new Error("剪太多啦！");

                updateStatus("正在處理剪接...", true);
                const startOffset = Math.floor(cutSeconds * audioBuffer.sampleRate);
                const newLength = audioBuffer.length - startOffset;

                updateStatus("編碼為 MP3 中 (LameJS)...", true);
                // Give UI a moment to update
                await new Promise(r => setTimeout(r, 50));

                const mp3Blob = await encodeMp3(audioBuffer, startOffset, newLength);
                
                finishProcess(mp3Blob, `cut_${selectedFile.name.split('.')[0]}.mp3`);

            } catch (error) {
                showError(error.message);
            }
        }

        function encodeMp3(audioBuffer, startOffset, length) {
            return new Promise((resolve, reject) => {
                try {
                    const channels = audioBuffer.numberOfChannels;
                    const sampleRate = audioBuffer.sampleRate;
                    const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, 128);
                    const mp3Data = [];
                    const leftData = audioBuffer.getChannelData(0);
                    const rightData = channels > 1 ? audioBuffer.getChannelData(1) : null;
                    const blockSize = 1152; 
                    
                    for (let i = 0; i < length; i += blockSize) {
                        const chunkLen = Math.min(blockSize, length - i);
                        const leftChunk = new Int16Array(chunkLen);
                        const rightChunk = rightData ? new Int16Array(chunkLen) : undefined;

                        for (let j = 0; j < chunkLen; j++) {
                            const idx = startOffset + i + j;
                            let s = Math.max(-1, Math.min(1, leftData[idx]));
                            leftChunk[j] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                            if (rightData) {
                                let s2 = Math.max(-1, Math.min(1, rightData[idx]));
                                rightChunk[j] = s2 < 0 ? s2 * 0x8000 : s2 * 0x7FFF;
                            }
                        }
                        const mp3buf = (channels === 1) ? mp3encoder.encodeBuffer(leftChunk) : mp3encoder.encodeBuffer(leftChunk, rightChunk);
                        if (mp3buf.length > 0) mp3Data.push(mp3buf);
                    }
                    const endBuf = mp3encoder.flush();
                    if (endBuf.length > 0) mp3Data.push(endBuf);
                    resolve(new Blob(mp3Data, { type: 'audio/mp3' }));
                } catch (e) { reject(e); }
            });
        }

        // ==========================================
        // Path 2: Heavyweight Video Processing (MP4 -> MP4)
        // ==========================================
        async function processVideoWithFFmpeg() {
            const cutSeconds = parseFloat(document.getElementById('cutSeconds').value);
            updateStatus("初始化影片引擎 (首次加載需時，約 25MB)...", true);
            document.getElementById('progressContainer').classList.remove('hidden');
            updateProgress(0);

            try {
                if (!ffmpeg) {
                    ffmpeg = createFFmpeg({ 
                        log: true,
                        // Important: Explicitly load core from CDN to avoid relative path issues on GH Pages
                        corePath: 'https://unpkg.com/@ffmpeg/core@0.10.0/dist/ffmpeg-core.js'
                    });
                    
                    ffmpeg.setProgress(({ ratio }) => {
                        updateProgress(ratio * 100);
                        if (ratio < 1) updateStatus(`處理中... ${Math.floor(ratio * 100)}%`, true);
                    });
                }

                if (!ffmpeg.isLoaded()) {
                    await ffmpeg.load();
                }

                const fileName = 'input_video.mp4';
                updateStatus("寫入檔案到虛擬記憶體...", true);
                
                // Write file to FFmpeg's virtual file system
                ffmpeg.FS('writeFile', fileName, await fetchFile(selectedFile));

                updateStatus("正在剪輯影片 (Stream Copy)...", true);
                
                // Using Stream Copy (-c copy) is fast and doesn't re-encode, 
                // but only cuts at keyframes. It's the only viable way for browser WASM performance.
                // -ss before -i is faster.
                const outputName = 'output_video.mp4';
                
                await ffmpeg.run(
                    '-ss', cutSeconds.toString(), 
                    '-i', fileName, 
                    '-c', 'copy',  // Critical: Copy streams instead of re-encoding
                    outputName
                );

                updateStatus("讀取輸出檔案...", true);
                const data = ffmpeg.FS('readFile', outputName);
                
                // Cleanup
                ffmpeg.FS('unlink', fileName);
                ffmpeg.FS('unlink', outputName);

                const blob = new Blob([data.buffer], { type: 'video/mp4' });
                finishProcess(blob, `cut_${selectedFile.name}`);

            } catch (error) {
                console.error(error);
                let msg = "影片處理失敗。";
                if (error.message && error.message.includes('SharedArrayBuffer')) {
                    msg += "瀏覽器安全限制 (SharedArrayBuffer) 導致無法執行。";
                } else {
                    msg += "請確保瀏覽器是最新版本。錯誤: " + error.message;
                }
                showError(msg);
            }
        }

        // --- Helpers ---
        function updateStatus(text, loading) {
            const area = document.getElementById('statusArea');
            const icon = document.getElementById('loadingIcon');
            area.classList.remove('hidden');
            document.getElementById('statusText').textContent = text;
            if (loading) {
                icon.classList.remove('hidden');
                document.getElementById('processBtn').disabled = true;
            } else {
                icon.classList.add('hidden');
                document.getElementById('processBtn').disabled = false;
            }
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = `${Math.min(100, Math.max(0, percent))}%`;
        }

        function showError(msg) {
            updateStatus(msg, false);
            const area = document.getElementById('statusArea');
            area.classList.add('bg-red-100', 'text-red-700');
            document.getElementById('progressContainer').classList.add('hidden');
        }

        function finishProcess(blob, filename) {
            updateStatus("搞掂！可以下載啦。", false);
            document.getElementById('progressContainer').classList.add('hidden');
            const url = URL.createObjectURL(blob);
            const link = document.getElementById('downloadLink');
            link.href = url;
            link.download = filename;
            link.classList.remove('hidden');
        }
    </script>
</body>
</html>
